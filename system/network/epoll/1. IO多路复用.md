### IO多路复用
又名事件驱动。什么叫事件呢？当操作系统发现socket或file可读、可写时，就发出一个通知，该通知就是一个事件（可读事件或可写事件）。当接收到事件时，就表征socket或file已经就绪，此时再对socket或file进行处理，就能够读取或写入数据。

在IO多路复用出现之前，当需要对多个描述符进行处理时，需要创建多个进程或线程，每个进程或线程分别处理一个描述符。当处理C10K问题时，这种方案显然不合适，进程或线程的切换就会占用大量的CPU。

借助操作系统提供的事件机制，我们可以使用一个线程来处理所有的描述符，由该线程负责监听所有描述符的通知事件，然后按照顺序依次处理接收到事件通知的描述符，这就是IO多路复用。

常用的多路复用技术由select、poll、kqueue，以及epoll等。

### 同步和异步
区别在于消息通信机制的不同。
- 同步：当同步调用执行后，在没有获取结果之前，它不会返回；而一旦同步调用返回了，它必然是获取到了调用结果；
- 异步：当异步调用执行后，它会立即返回，此时并没有返回调用结果，它能够继续处理其他事务。当被调用方执行完毕之后，它会通知调用方，主要有信号、回调等方式。

### 阻塞与非阻塞
区别在于等待调用结果时的状态。
- 阻塞：在调用返回结果之前，当前线程会被挂起，并在获得调用结果之后恢复；
- 非阻塞：在调用放回结果之前，当前线程不会被挂起，可以处理其他事务。

```
+-----------|---------------------------------+
|           |           IO多路复用             |
|           |     select/poll/epoll/kqueue    |
|    同步    |----------------|----------------
|           |       阻塞      |      非阻塞    |
+-----------|----------------|----------------+
                                               
+-----------|----------------|----------------+
|           |      linux     |     windows    |
|    异步    |---------------------------------
|           |       AIO      |      IOCP      |
+-----------|----------------|----------------+
```

### socket事件
1. 可读事件
	- socket内核接收缓冲区中可用字节数大于或等于其低水位线SO_RCVLOWAT，默认值为1
	- socket对端关闭连接（对端发送FIN），缓冲区中有EOF，读操作立即返回0
	- 监听socket的backlog队列已经有完成三次握手的连接请求，此时可以accept
	- socket上有未处理的错误，可以调用getsockopt来读取或清除错误信息
2. 可写事件
	- socket内核发送缓冲区中可用字节数大于或等于其低水位线SO_SNDLOWAT
	- socket写端被关闭，继续写会收到SIGPIPE信号
	- 非阻塞模式下，connect连接成功，或者失败（超时）
	- socket上有未处理的错误，可以调用getsockopt来读取或清除错误信息