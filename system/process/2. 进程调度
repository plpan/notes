### 进程调度
主要介绍三部分：
- 调度策略：linux调度选择
- 调度算法：实现调度所使用的数据结构和算法
- 系统调用：介绍相关联的系统调用

#### 调度策略
首先，调度器有一组目标：
- 进程响应时间要快
- 后台作业吞吐量要打
- 尽可能避免饥饿现象
- 实现对进程的优先级调度
注意，这一组目标互相冲突。因此，制定一个合适的调度策略非常重要。

linux使用分时调度技术：多个进程以“时间多路复用”的方式运行，CPU时间被分成片，每个进程被分配一片，同一时刻，CPU只会执行一个进程，当进程运行的时间片到期后，就会发生进程切换。linux进程具有优先级，优先级越高的进程占用CPU时间越长。然而，这个优先级是动态变化的，当一个进程长时间没有被运行，那么它的优先级会被自动提升，以避免饥饿；当一个进程长时间运行时，那么它的优先级会被降低。

#### 内核抢占
linux进程是抢占式的，如果进程进入TASK_RUNNING状态，内核会检查它的动态优先级是否大于当前进程，如果是，那么当前进程current会被中断，并调用调度程序选择另一个进程开始执行（通常是刚变为可运行状态的进程）。此外，当进程的时间片到期后，它也会被抢占，当前进程thread_info结构体中TIF_NEED_RESCHED标志被设置，以便时钟中断处理程序终止时调度程序被调用。

注意，当一个进程被强占时，它并未被挂起，因为他还处于TASK_RUNNING状态。而且由于linux内核是抢占式的，因此，无论是用户进程，还是内核进程，都能够被强占。

#### 调度算法
调度算法主要有：
- SCHED_FIFO：先进先出的实时进程。进程持续保留在运行队列的当前位置，如果没有更高优先级的进程，那么它将一直运行下去，即使其他进程拥有相同的优先级。
- SCHED_RR：时间片轮转的实时进程。将进程描述符添加到运行队列的队尾，这样保证具有相同优先级的进程都能被调度执行。
- SCHED_NORMAL：普通的分时进程。

