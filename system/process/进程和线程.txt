1. 概念简介
进程和线程是操作系统核心抽象之一，几乎所有的书籍中都会如下介绍进程和线程：
- 进程是资源管理的最小单元
- 线程是程序执行的最小单元

进程管理着资源（如CPU、内存、文件等），以及一个线程集合。线程则负责实际的程序执行，会被安排到某个CPU上，然后执行对应的任务。当然，一个进程可以拥有多个线程，这样就能够充分利用现代SMP架构处理器。

注意，进程之间的资源是相互隔离的，而同一个进程的线程之间部分数据是共享的，线程相关的数据（如寄存器、堆栈、TLS存储等）。如果多个线程同时需要访问共享资源，那么需要额外的手段来保证数据的同步，如加锁、信号量等技术，否则会出现意想不到的结果。

从这里我们也可以看出，相较于线程切换，进程切换需要替换的数据结构明显要多得多，受制于缓存容量的限制，频繁的进程切换所带来的代价更加难以让人接受。这就是多线程快速发展的主要驱动力之一。

针对线程，还可以将其分为用户线程和内核线程：
- 用户线程：线程的创建和销毁由内核完成，但是线程管理相关的工作都是由应用程序来完成的，内核唯一感知到的是一个进程，而感知不到用户线程的存在。这就是”多对一模型“
	- 这种模式的优点很明显，就是调度开销小，无需内核接入；线程仅和本进程的线程争夺资源。如通过setjmp和longjmp就可以实现线程的跳转[1]
	- 但是它也有个最大的问题，就是当线程发生I/O或其他事件造成阻塞时，整个进程都将被挂起。
- 内核线程：线程的创建和销毁都是由linux内核来完成，并且线程的管理也同样由内核来完成；线程和所有进程的所有线程去争夺资源。
	- 这种模式优点也很明显，那就是可以同时执行进程中的多个线程，并且当一个线程阻塞时，不会影响其他线程的执行（参考下面一段话加以理解）
	- 而其缺点就是线程切换代价略大，但是在linux系统经过了大量的优化之后，其性能还是令人满意的。

注意，用户线程想要实现最终的任务执行，那么它就必须绑定到内核线程上，因为对CPU、内存的操作都必须由内核线程来完成。根据用户线程和内核线程的绑定关系，主要有如下几种模型：
- 应用程序的所有用户线程都绑定到一个内核线程上，那么这就是“多对一模型”
- 应用程序的每一个用户线程都绑定到一个内核线程上，那么这就是“一对一模型” (linux pthread就是“一对一模型”)
- 应用程序的用户线程绑定到一定数量（少于或等于用户线程数目）的内核线程上，那么这就是“多对多模型“ （go语言就是”多对多模型“）
更详细的说明，可以参见[2]

此外，linux中经常还出现一个轻量级进程的概念。轻量级进程本质上就是用户线程和内核线程一对一的映射关系，轻量级进程就是共享了大量资源的进程。看完下一节，你就能更加清晰的理解linux内核中进程、内核线程、轻量级进程时间的联系。

2. 内核实现
想要彻底理解linux内核中进程和线程的概念，就必须掌握其数据结构和操作方式。在linux系统中，使用进程描述符task_struct[3]来描述一个进程。在这个结构体中：
- pid字段记录进程号，注意这个pid就是我们运行 ps 程序时显示的PID列，
    - 注意linux内部使用双向链表串起每个队列中所有的进程描述符，但是，也提供hash的方式快速定位pid为指定值的进程描述符
- tgid字段记录线程组id，后文有描述
- thread_info字段[4]记录线程相关的属性，如线程栈、CPU属性、标识符等
    - task_struct和thread_info中分别有一个指针互相引用
- 其他字段：分别描述进程占用的内存页、信号处理、定时器等属性

在linux内核中线程也是用task_struct来描述的，那么线程和进程有什么联系和区别呢？
- linux系统中，进程和线程的创建最终都会调用do_fork系统函数[5]，其中clone_flags标志位参数指明了创建task_struct时需要复用的数据，也正是这个参数区分了是创建一个进程还是创建一个进程
	- CLONE_VM：共享内存空间
	- CLONE_FS：共享文件系统信息
	- CLONE_FILES：共享打开的文件描述符表
	- CLONE_SIGHAND：共享信号处理函数
	- ...
- 创建进程时，不设置任何共享标志位，这样创建的进程将会拥有独立的一份资源
	- fork系统调用就是创建一个新的进程，其资源和父进程一致，但是父子进程之间资源相互独立。linux系统使用COW（写时复制）的技术来优化进城创建过程的代价，这是因为：a.子进程并非立即就要访问这些资源； b.如果系统紧接着执行exec系统函数，那么就无需复制任何资源。
- 创建线程时，需要设置所有的共享标志位，这样创建的子进程和父进程共享几乎所有的资源，除了寄存器、栈等属性

注意，在linux 2.6版本之前，内核对线程的抽象比较弱，因为task_struct中只有一个PID来表示其线程ID，每个线程都拥有自己的PID，这不符合POSIX的标准规范。而在linux 2.6版本中首次引入了tgid，如果线程为当前进程的主线程，则其tgid等于进程的pid，否则其tgid等于父进程的tgid，从此线程的概念才逐步明晰。

3. 多线程模型
在linux多线程的发展史上，主要有三种模型：
- LinuxThreads
- NPTL
- NGPT

linux 2.6之前的内核使用LinuxThreads模型，它使用一个管理线程来实现线程的管理，负责线程的创建和同步。管理线程与其他线程之间通过一个”一对一“的管道进行通讯，该管道在创建线程之前创建。
这个模式的问题有：
- 由于管理线程的存在，所有的用户线程都要和管理线程进行交互，这严重限制了多线程的并发
- 更重要的是，由于linux内核缺少对线程的抽象，每个线程的进程ID都不同，这就使得对信号、线程状态的管理变得非常困难

目前主流的多线程模型就是NPTL，这个由RedHat公司研发的多线程模型是建立在linux 2.6版本内核之上。它解决了LinuxThreads所带来的种种弊端，并且兼容Posix标准。

最后是IBM研发的NGPT多线程模型，其本质上要实现的是M:N模型，但由于种种原因，NGPT在2003年就停止升级了。

因此，目前linux系统中所使用的多线程模型都是NPTL。用户可以通过调用pthread库提供的函数来创建多线程程序：
- pthread_create创建线程
- pthread_attr_setscope设置线程资源竞争的范围，也即到底是创建一个用户线程（PTHREAD_SCOPE_PROCESS），还是创建一个内核线程（PTHREAD_SCOPE_SYSTEM）
- pthread_join等待一个线程终止
- pthread_exit终止线程
注意，由于linux仅支持”一对一模型“，因此在linux系统中调用 pthread_attr_setscope(&attr, PTHREAD_SCOPE_PROCESS) 将会返回 ENOTSUP 错误码[6]

[1]. https://github.com/plpan/ctest/tree/master/jmp
[2]. https://blog.csdn.net/gatieme/article/details/51892437
[3]. https://github.com/plpan/linux/blob/master/include/linux/sched.h#L528
[4]. https://github.com/plpan/linux/blob/master/include/asm-x86_64/thread_info.h#L26
[5]. https://github.com/plpan/linux/blob/master/kernel/fork.c#L1165
[6]. http://man7.org/linux/man-pages/man3/pthread_attr_setscope.3.html
