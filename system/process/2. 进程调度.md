### 进程调度
主要介绍三部分：
- 调度策略：linux调度选择
- 调度算法：实现调度所使用的数据结构和算法
- 系统调用：介绍相关联的系统调用

依照传统，进程主要被分为两大类：
- IO密集型(io-bound)：频繁地使用IO设备，并花费很长时间等待IO操作的完成
- CPU密集型(cpu-bound)：需要大量的CPU时间来执行相关计算

此外，还有一种分类方法：
- 交互式进程(interactive)：与用户进行交互。在用户输入之前有一个很长的等待时间，然而当用户输入后，进程必须被很快唤醒。延迟一般在50ms~150ms。如shell进程
- 批处理进程(batch)：后台执行，不必被很快响应。如编译程序
- 实时进程(real-time)：不会被低优先级的进程阻塞，响应时间非常短。如视频和音频处理程序

那么linux内核如何判断进程是属于哪个类别呢？内核可以确认所有实时进程的身份，但是却没法区分交互式进程和批处理进程。取而代之的是使用一种启发式算法，根据进程的历史行为，以判断其是交互式进程还是批处理进程。当然，内核更倾向于调度交互式进程。

#### 调度策略
首先，调度器有一组目标：
- 进程响应时间要快
- 后台作业吞吐量要打
- 尽可能避免饥饿现象
- 实现对进程的优先级调度
注意，这一组目标互相冲突。因此，制定一个合适的调度策略非常重要。

linux使用分时调度技术：多个进程以“时间多路复用”的方式运行，CPU时间被分成片，每个进程被分配一片，同一时刻，CPU只会执行一个进程，当进程运行的时间片到期后，就会发生进程切换。linux进程具有优先级，优先级越高的进程占用CPU时间越长。然而，这个优先级是动态变化的，当一个进程长时间没有被运行，那么它的优先级会被自动提升，以避免饥饿；当一个进程长时间运行时，那么它的优先级会被降低。

#### 进程抢占
linux进程是抢占式的，如果进程进入TASK_RUNNING状态，内核会检查它的动态优先级是否大于当前进程，如果是，那么当前进程current会被中断，并调用调度程序选择另一个进程开始执行（通常是刚变为可运行状态的进程）。此外，当进程的时间片到期后，它也会被抢占，当前进程thread_info结构体中TIF_NEED_RESCHED标志被设置，以便时钟中断处理程序终止时调度程序被调用。

注意，当一个进程被强占时，它并未被挂起，因为他还处于TASK_RUNNING状态。而且由于linux内核是抢占式的，无论是用户进程，还是内核进程，都能够被强占。

#### 调度算法
调度算法主要有：
- SCHED_FIFO：先进先出的实时进程。进程持续保留在运行队列的当前位置，如果没有更高优先级的进程，那么它将一直运行下去，即使其他进程拥有相同的优先级。
- SCHED_RR：时间片轮转的实时进程。将进程描述符添加到运行队列的队尾，这样保证具有相同优先级的进程都能被调度执行。
- SCHED_NORMAL：普通的分时进程。

调度算法区分普通进程和实时进程：

1）普通进程

每个普通进程都有自己的静态优先级，内核定义的静态优先级范围是100(最高优先级)~139(最低优先级)，而调度程序正是使用静态优先级来调度所有的普通进程。

子进程总是继承父进程的静态优先级，但是可以通过系统调用修改nice值来改变进程自身的静态优先级。

静态优先级计算公式：基本时间片(ms) = IF(sp >= 120) (140 - sp) * 5 ELSE (140 - sp) * 20，其中sp指代进程的静态优先级。这个公式表明，进程的静态优先级越高（其值越小），它占用的时间片越长。详见下表：

说明 | 静态优先级 | nice值 | 基本时间片 | 交互式δ值 | 睡眠时间的极限值
--- | --------- | ------ | -------- | -------- | ---------------
最高静态优先级 | 100 | -20 | 800ms | -3 | 299ms
高静态优先级 | 110 | -10 | 600ms | -1 | 499ms
缺省静态优先级 | 120 | 0 | 100ms | +2 | 799ms
低静态优先级 | 130 | +10 | 50ms | +4 | 999ms
最低静态优先级 | 139 | +19 | 5ms | +6 | 1199ms

普通进程除了静态优先级之外，还有动态优先级，其值范围是100（最高）\~139（最低）。动态优先级是调度程序选择新进程来运行时使用的标准。它的计算公式：动态优先级 = max(100, min(静态优先级 - bonus + 5, 139))。其中bonus取值范围0\~10；小于5则减小动态优先级以示惩罚，大于5则增大动态优先级以示奖励。

bonus值的计算依赖于进程过去的平均睡眠时间，也即进程在睡眠状态的平均纳秒数。注意，这不是一个简单的求均值操作，运行中的进程平均睡眠时间在递减，并且平均睡眠时间不会超过1秒。具体的对应关系见下表：

平均睡眠时间 | bonus | 粒度
---------- | ------ | ----
\>= 0 && < 100ms | 0 | 5120
\>= 100ms && < 200ms | 1 | 2560
\>= 200ms && < 300ms | 2 | 1280
\>= 300ms && < 400ms | 3 | 640
\>= 400ms && < 500ms | 4 | 320
\>= 500ms && < 600ms | 5 | 160
\>= 600ms && < 700ms | 6 | 80
\>= 700ms && < 800ms | 7 | 40
\>= 800ms && < 900ms | 8 | 20
\>= 900ms && < 1s | 9 | 10
1s | 10 | 10

此外，平均睡眠时间也被用来判定一个进程是交互式进程还是批处理进程。交互式进程判断公式：
- 动态优先级 <= 3 * 静态优先级 / 4 + 28
- 或：bonus - 5 >= 静态优先级 / 4 - 28
其中(静态优先级 / 4 - 28) 即为δ值。同时，高优先级的进程更容易被当做交互式进程。

为了防止系统中低优先级的进程饿死，内核实现了：当一个高优先级进程用完它的时间片之后，该进程就会被还没有用完时间片的低优先级的进程取代。这就涉及到以下两类进程：
- 活动进程：还没有用完时间片
- 过期进程：已经用完时间片，它暂时被禁止运行，直到所有活动进程都过期
批处理进程总是在用完时间片之后成为过期进程，而交互式进程在用完其时间片之后，还是被放到活动进程队列。当然为了防止饥饿现象，内核保证交互式进程在适当的时候进入过期进程队列。

2）实时进程

每个实时进程都有对应一个实时优先级，取值范围：1 (最高) \~ 99 (最低)。调度程序总是让优先级高的进程执行，也即实时进程执行过程中，禁止低优先级进程执行，并且实时进程总是被当做活动进程。

如果出现多个相同优先级的实时进程，CPU会选择第一个出现在相应运行队列链表的进程。

当然实时进程也会退出，退出条件有：
- 被另一个更高实时优先级的进程取代
- 进程执行阻塞操作，并进入睡眠状态 (TASK_INTERRUPTIBLE或TASK_UNINTERRUPTIBLE)
- 进程停止 (TASK_STOPPED或TASK_TRACED) 或被杀死 (EXIT_ZOMBIE或EXIT_DEAD)
- 进程调用sched_yield系统调用自愿放弃CPU
- 进程是基于时间片轮转的实时进程，并且已经用完时间片
当系统调用nice和setpriority用于基于时间片轮转的实时进程时，不会改变进程的实时优先级，但是会改变其基本时间片长度。实际上，基于时间片轮转的实时进程的基本时间片长度与实时进程的优先级无关，而是依赖于进程的静态优先级。