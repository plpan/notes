### 内核抢占
如果进程正在执行内核函数，也即它在内核态运行，并且允许发生内核切换，也即允许另一个进程代替本进程来占用CPU执行程序，这就是内核抢占。

无论是抢占内核，还是非抢占内核，当前运行在内核态的进程都可以主动放弃CPU。如因为等待I/O事件而放弃CPU，进入睡眠状态。然而，非抢占内核只能执行计划性内核切换，而抢占内核还可以执行抢占式内核切换。

所有的进程切换都是由switch_to函数来完成。当进程执行完某些具有内核功能的线程，并且调度程序被调用，就发生进程切换。不过在非抢占内核中，除非进程主动放弃CPU，否则，当前进程不可能被替换。

因此，总结下抢占内核的两个特点：
- 运行在内核态的线程
- 在内核函数执行期间可以被另一个进程取代

linux内核对抢占的支持主要体现在task_struct->thread_info结构体中的preempt_count字段，当该字段大于零是，就禁止内核抢占。当一下任何一种情况发生时，该字段都大于0：
- 内核正在执行中断服务程序
- 可延迟函数被禁止（软中断或tasklet）
- 显式指定该字段值大于0，来禁止内核抢占

也即只有当内核在执行异常处理程序（如系统调用），而且内核抢占没有被显式禁止时，才可以抢占内核。注意，本地CPU必须打开中断，否则无法完成内核抢占。

抢占内核的一个宏preempt_enable定义如下：
```
if (!current_thread_info->preempt_count && !irqs_disabled()) {
	current_thread_info->preempt_count = PREEMPT_ACTIVE;
	schedule();
	current_thread_info->preempt_count = 0;
}
```
其含义就是：如果检测到内核允许中断，并且preempt_count字段等于0，就调用调度程序选择另一个进程来执行。

内核抢占发生的时机主要有：
- 中断处理程序结束时
- 异常处理程序调用preempt_enable时
- 启用可延迟函数时

最后，需要注意的是，内核抢占会带来非常大的开销。