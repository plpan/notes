### 临界区
临界区就是一段代码，其他进程进入临界区前，必须等待已进入临界区的进程执行完临界区中的所有代码。

至于为什么要有临界区，这是因为多个进程有可能交叉访问一些公共资源，最终结果就是会导致数据的不一致现象。因此，内核必须准确的识别出相关的临界区，并实施必要的手段，保证临界区内的资源只能被互斥的访问。

针对单CPU系统，只需简单的禁用内核抢占功能来实现临界区。而针对多CPU系统，我们则需要一些特定的同步技术来实现临界区。

### 同步原语
linux系统下常见的同步原语有如下几种：
```
技术 | 说明 | 使用范围
---- | --- | ----
每CPU变量 | 在CPU之间共享 | 所有CPU
原子操作 |  对一个数据原子操作（读-修改-写） | 所有CPU
内存屏障 | 避免指令重排 | 所有CPU
自旋锁 | 加锁时忙等 | 本地CPU或所有CPU
信号量 | 加锁时阻塞等待（睡眠） | 所有CPU
顺序锁 | 基于访问计数器的锁 | 所有CPU
禁止本地中断 | 禁止单个CPU的本地中断 | 本地CPU
禁止本地软中断 | 禁止单个CPU的本地可延迟函数处理 | 本地CPU
读-拷贝-更新（RCU） | 通过指针来共享数据，而非加锁 | 所有CPU
```

#### 每CPU变量
最直接的同步就是避免数据冲突，也即使用每CPU变量，CPU只能访问自己的元素，而不能访问其他CPU的元素。每CPU变量可以借助内存排列，使其对应不同的缓存行。因为多个CPU同时对一个缓存行进行操作就涉及到数据同步。

一般对每CPU变量的操作需要禁止本地CPU中断和软中断，否则发生进程抢占时，数据会发生冲突。

这种方式一般仅限在内核中使用，用户态下很少用到。

#### 原子操作
假定多个CPU同时对一个变量进行‘读-修改-写’的操作，如果不添加任何防护措施，最终得到的结果将会出乎意料，因为这个过程不是原子操作。

最直接的想法就是添加原子指令，让这个过程变为原子操作，任何这样的操作都必须以单个指令操作，中间不能中断。当然，这需要芯片来保证。

现在，根据这个准则来回顾80x86的指令：
- 进行零次或一次对齐内存访问的汇编指令是原子的
- 如果在读之后、写之前没有其他处理器占用总线，那么“读-更新-写”指令（inc，dec）是原子的。单处理器系统中不会发生内存总线被窃取的情况
- 操作码前缀是lock，那么“读-更新-写”指令也是原子的。当控制单元检测到这个前缀时，就锁定内存总线，指导这条指令执行完毕
- 操作码前缀是rep（0xf2，0xf3）的汇编指令不是原子的。这条指令强制控制单元多次重复执行相同的指令。但是在每次执行前都必须检查挂起的中断

为了使程序员更方便的进行原子操作，linux内核提供了专门的函数和宏，操作对应的atomic_t类型的变量，实现原子操作。如
- atomic_read
- atomic_set
- atomic_add
- ...
注意，所有的原子操作函数或宏，最终都会在生成的汇编语句前添加lock前缀。

