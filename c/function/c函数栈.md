### IA32 function stack
本文主要介绍32位系统运行时函数栈的详细细节。

c语言函数调用时，主要涉及一下几个重点：
1. 指令跳转
2. 函数返回
3. 参数传递
4. 返回值传递
所有的函数调用无非就是这四点，现在的问题是：c语言如何处理这四个部分的？

首先，是指令跳转，这个很方便，c语言汇编提供了很多跳转指令，函数跳转通常会使用两条：
1. jmp
2. call
jmp就是一条简单的跳转指令，跳转到label所表示的地址，不做任何额外的操作；而call首先会将函数返回地址保存起来，然后在执行jmp指令。

然后，是函数返回，也就是一条跳转指令，通常都是使用ret指令，返回到caller的调用栈，然后接着执行函数调用者的指令。
这里有个问题，函数的返回地址是保存在哪里呢？如果将返回指令保存在寄存器中，那么函数调用将无法处理多级函数调用，如a调用b，b调用c，这就会导致寄存器中的值被覆盖，最终b将无法返回到a。其实真实的做法是将返回地址保存在栈中，因为每个函数都有自己的函数栈，这也就避免了多级函数调用时返回地址互相覆盖的问题。

接着，是参数的传递，我们知道在系统调用的时候，参数传递首先的是寄存器，前六个参数保存在寄存器中，而多余的参数则一次被保存在栈中。c语言对函数参数的处理是都保存在栈中，并且是后面的参数先入栈，而前面的参数后入栈。

最后，是返回值的处理，返回值处理一般也就两种方式：栈和寄存器，c语言选择了使用寄存器EAX来传递返回值，这就限制了返回值的个数只能为1。

了解了函数调用的细节之后，我们再来看函数调用时栈的活动细节：
系统中有一个专门的寄存器来保存当前栈的指针位置，ESP，而函数调用时栈的活动其实就是ESP的活动。并且ESP是向着低地址增长的。
我们假设在函数调用之前，ESP的位置0x1000。当函数调用时，函数的传入参数首先需要入栈，其次是函数的返回地址。然后可以执行jmp指令跳转到函数代码中去执行了，这里系统会为这个被调函数分配一个新的函数栈，栈的初始位置由ESP所指向的位置决定。在函数执行的过程中，如果有局部变量的分配，系统都会在函数栈中分配对应的大小来保存这个局部变量。最后当函数执行完毕时，将返回值保存在EAX寄存器中，再执行ret指令返回到函数的调用者，这时ESP会自动调整其指针指向函数调用者的函数栈。

函数调用时其函数栈简单示意如下：
```
0x1000 -- caller函数栈起始位置
       Param N
       Param N-1
       ...
       Param 1
       EIP (返回地址)
0x00XX -- caller函数栈终止位置（callee函数栈起始位置）
       Local 1
       Local 2
       ...
       Local N
```

在函数调用时，ESP会随着指令的指令在不断发生变化（局部变量的声明），而函数参数的获取都是依赖于ESP，怎么搞定定位呢？
系统的做法是新增一个寄存器EBP，指向函数栈的栈底，而ESP则指向函数栈的栈顶。不论栈顶会如何变化，栈底始终保持不变，参数地址固定是EBP-4-4i，i表示第i个参数。

新版函数栈示意如下：
```
0x1000 -- caller的栈底
       Param N
       Param N-1
       ...
       Param 1
       EIP (返回地址)
       EBP
0x00XX -- caller的栈顶；callee的栈底 (push ebp, mov esp, ebp)
       Local 1
       Local 2
       ...
       Local N
```

到这里，其实还不完美，因为函数在执行的过程中，会使用到一些寄存器，如果caller和callee都使用了同一个寄存器，那么只会出现覆盖的问题。解决方案也很简单，函数执行时，先将使用到的寄存器保存到栈中，而当函数调用结束时，在将寄存器的值恢复出来。堆栈示意图建议读者亲自画出来感受下。

学写了以上内容之后，我们算是对函数栈有了一个基本的认识。更多的细节还有待我们去了解。

Reference：https://www.cs.princeton.edu/courses/archive/spr11/cos217/lectures/15AssemblyFunctions.pdf