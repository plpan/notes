### gcc-inline-asm
gcc使用的汇编语法是AT&T，因此本文使用的都是AT&T风格的汇编。

gcc允许用户在c代码中编写汇编代码，写法如下：
	asm ( assembler template );
	__asm__ ( assembler template );
其中汇编语句以字符串形式添加在asm函数体中。而如果assembler template包含多条汇编语句，则每条汇编语句自成一行，并以'\n'和'\t'结尾。gcc编译器会自动将以newline/tab分隔的汇编代码发送至as进行汇编处理。

我们来看个具体的例子：
	__asm__ ("movl %eax, %ebx\n\t"
		"movl $56, %esi\n\t"
		"movl %ecx, $label(%edx,%ebx,$4)\n\t"
		"movb %ah, (%ebx)");
在这个例子中，我们使用汇编代码对一些寄存器进行了赋值操作，然而，编译器并不能感知到寄存器的值发生了变化，如果编译器仍然假设寄存器中的值还是原先的值，那么程序就会出现不可预料的问题。这种原始汇编代码还不能实现按照变量名对其值进行操作的功能。

因此，gcc扩展汇编代码使其具备了更加强大的功能。其格式如下：
	asm ( assembler template 
		: output operands                  /* optional */
		: input operands                   /* optional */
		: list of clobbered registers      /* optional */
		);
扩展汇编多出了三个部分：输出操作数，输入操作数和脏寄存器列表。输入和输出操作数的格式都是：操作数约束+c语言变量名。如果输入或输入有多个值，则以都好分隔。而如果没有输出，只有输入，输出行的冒号还是需要被保留。

再来看个简单例子：
	int a=10, b;
	asm ("movl %1, %%eax; 
		movl %%eax, %0;"
		:"=r"(b)        /* output */
		:"r"(a)         /* input */
		:"%eax"         /* clobbered register */
		); 
这里实现的功能就是将变量a的值赋给变量b。其中%1和%0分别指代变量a和变量b，操作数按照其出现的顺序依次被命名为%0，%1，...。而输入操作数的操作数约束是"r"，表示gcc使用任意寄存器来存储这个操作数；而输出操作数的约束也同样是"r"，但是他还有一个约束描述符"="，表明输出操作数是可写（必须是左值，不能使表达式等）。由于汇编代码中使用了eax寄存器，就将其保存在脏寄存器列表中，已告知gcc。

如果表示一个变量可读可写，也很简答，让该变量同时出现在输出和输入操作数列表即可，如：
	asm ("leal (%0,%0,4), %0"
		: "=r" (five_times_x)
		: "0" (x) 
		);
由于five_times_x是第一个操作数，因此为%0，并限制其可写，而输入操作数也同样使用了%0，则%0具备了可读可写的能力。

上面的例子其实还可以更进一步，上面的例子我们允许gcc使用任意寄存器来完成操作，我们还可以指定特定的寄存器来完成其功能：
	asm ("leal (%%ecx,%%ecx,4), %%ecx"
		: "=c" (x)
		: "c" (x) 
		);
"c"表示我们要使用ecx寄存器。至于这里为什么没有将ecx添加到脏寄存器中，是因为gcc编译器能够清楚的感知到ecx寄存器的内容，因此无需将其添加到脏寄存器列表中，只有那些无法感知的变更才需要。

现在我们再来学习扩展汇编的格式：
1. 汇编指令需要被包含在""符号内
2. 多条汇编指令的分割符可以是"\n"，也可以是";"
3. 操作数按照其在输出输入列表中出现的顺序依次被命名为%0，%1，。。。
4. c变量是作为操作数被分别放置与输出列表和出入列表，他们都有一个操作数约束，表示其存储介质（寄存器、内存、或立即数等），同时输出操作数还有一个操作数约束，限制其可写
5. 脏寄存器列表中所列的寄存器不能出现在输出和输入操作数列表中，因为汇编代码中需要对这些值进行修改，会覆盖这些值
6. 如果我们要求汇编代码必须按照我们给定的顺序执行，则需要添加volatile关键字，其使用方法为：asm volatile ( ... : ... : ... : ...);由于volatile会影响系统优化，因此必须慎重使用

接着，我们再来学些操作数的约束：
1. "r": 寄存器
	a: %eax, %ax, %al
	b: %ebx, %bx, %bl
	c: %ecx, %cx, %cl
	d: %edx, %dx, %dl
	S: %esi, %si
	D: %edi, %di
2. "m": 内存
3. 其他更多的约束可以参考：http://www.ibiblio.org/gferg/ldp/GCC-Inline-Assembly-HOWTO.html#ss6.1

最后，我们学习操作数约束的限定符：
1. "=": 可写，表示操作数是一个左值
2. "&": 表名其值会被修改，仅被用做输入操作数，并且仅能在其值被修改前使用

最后，当掌握了以上内容之后，我们在来看一个例子：
	__asm__ __volatile__(
		"   lock       ;\n"
		"   addl %1,%0 ;\n"
		: "=m"  (my_var)
		: "ir"  (my_int), "m" (my_var)
		:                                 /* no clobber-list */
		);
这段汇编代码实现的功能是：使用寄存器保存my_int的int值，并将其累加到使用内存保存的my_var变量中，并且禁止编译器优化代码。